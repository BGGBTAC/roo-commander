# SvelteKit Service Workers

Implementing basic offline support and caching strategies using service workers in SvelteKit.

## Core Concept

A service worker is a script that your browser runs in the background, separate from a web page, enabling features like offline support, push notifications, and background syncs. SvelteKit provides utilities to simplify service worker registration and interaction.

## Setup

1.  **Create `src/service-worker.js` (or `.ts`):** This is the entry point for your service worker logic.
2.  **Enable in `svelte.config.js`:** Ensure the `serviceWorker.register` option is `true` (which is often the default).
    ```javascript
    // svelte.config.js
    import adapter from '@sveltejs/adapter-auto';
    import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

    /** @type {import('@sveltejs/kit').Config} */
    const config = {
      preprocess: vitePreprocess(),
      kit: {
        adapter: adapter(),
        serviceWorker: {
          register: true, // Default is true, explicitly shown here
          // Use `files` to customize which build assets are precached
          // files: (filepath) => !/\.DS_Store/.test(filepath)
        },
        // ... other kit options
      }
    };
    export default config;
    ```

## Service Worker File (`src/service-worker.js`)

This file uses standard Service Worker APIs, but SvelteKit provides helpful modules via `$service-worker`.

```javascript
// src/service-worker.js
/// <reference types="@sveltejs/kit" />
import { build, files, version } from '$service-worker';

// Create a unique cache name for this version of the app
const CACHE = `cache-${version}`;

const ASSETS = [
  ...build, // All routes and assets generated by SvelteKit/Vite
  ...files  // All static files in your `static` directory
];

// Install event: Precache assets
self.addEventListener('install', (event) => {
  async function addFilesToCache() {
    const cache = await caches.open(CACHE);
    await cache.addAll(ASSETS);
  }
  event.waitUntil(addFilesToCache());
  console.log('[Service Worker] Installed and assets cached');
});

// Activate event: Clean up old caches
self.addEventListener('activate', (event) => {
  async function deleteOldCaches() {
    const keys = await caches.keys();
    for (const key of keys) {
      if (key !== CACHE) {
        await caches.delete(key);
      }
    }
  }
  event.waitUntil(deleteOldCaches());
  console.log('[Service Worker] Activated and old caches removed');
});

// Fetch event: Serve assets from cache (Cache First strategy)
self.addEventListener('fetch', (event) => {
  // Ignore non-GET requests
  if (event.request.method !== 'GET') return;

  async function respond() {
    const url = new URL(event.request.url);
    const cache = await caches.open(CACHE);

    // Try serving from the cache first
    const cachedResponse = await cache.match(event.request);
    if (cachedResponse) {
      return cachedResponse;
    }

    // If not in cache, try fetching from the network
    try {
      const response = await fetch(event.request);

      // Optional: Cache successful GET requests for non-asset paths (e.g., API calls)
      // Be careful with caching dynamic data - consider network-first or stale-while-revalidate here.
      // if (response.status === 200 && !ASSETS.includes(url.pathname)) {
      //   cache.put(event.request, response.clone());
      // }

      return response;
    } catch (error) {
      // Network fetch failed (offline?)
      console.error('[Service Worker] Fetch failed:', error);
      // Optional: Return a fallback offline page
      // const offlineFallback = await cache.match('/offline.html');
      // if (offlineFallback) return offlineFallback;
      // Or just let the browser handle the error
      throw error;
    }
  }

  event.respondWith(respond());
});

// Optional: Listen for skipWaiting message
self.addEventListener('message', event => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

```

## Key `$service-worker` Modules

*   **`build`**: An array of URLs for all SvelteKit-generated routes and assets (JS, CSS chunks). Essential for precaching the application shell.
*   **`files`**: An array of URLs for all files in your `static` directory. Useful for precaching static assets like images, fonts, manifests.
*   **`version`**: A unique string generated for each build. Useful for naming caches and cleaning up old ones during activation.
*   **`prerendered`**: An array of URLs for routes that were prerendered at build time.

## Caching Strategies (Common Examples)

*   **Cache First (Offline First):** (Shown above) Try cache first. If not found, fetch from network. Good for app shell and static assets.
*   **Network First:** Try network first. If fails (offline), fallback to cache. Good for frequently changing data where freshness is preferred.
*   **Stale-While-Revalidate:** Serve from cache immediately (stale). Simultaneously, fetch from network in the background and update the cache for the next request. Good balance for resources that update but where showing stale data briefly is acceptable.

## Updating the Service Worker

*   When you build a new version of your app, the `version` string changes.
*   The browser detects the new service worker file.
*   The `install` event runs for the new worker, caching new assets.
*   The new worker enters a `waiting` state until all tabs using the old worker are closed.
*   You can prompt the user to refresh or use `self.skipWaiting()` (often triggered by a message from the client) to activate the new worker sooner.
*   The `activate` event runs, cleaning up old caches.

## Considerations

*   **Scope:** By default, the service worker controls pages under its scope (usually the root `/`).
*   **HTTPS:** Service workers require HTTPS (except for `localhost`).
*   **Debugging:** Use browser developer tools (Application -> Service Workers) to inspect, debug, and manage service workers. Enable "Update on reload" during development.
*   **Complexity:** Advanced caching strategies and features like background sync or push notifications can add significant complexity.

*(Refer to the official SvelteKit Service Worker documentation: https://kit.svelte.dev/docs/service-workers)*