# SvelteKit: Service Workers

Implementing offline capabilities and background features using Service Workers in SvelteKit.

## Core Concept: Service Workers

A Service Worker is a script that runs in the background, separate from the web page, enabling features like:

*   **Offline Support:** Intercepting network requests and serving cached responses when the user is offline.
*   **Background Sync:** Syncing data in the background even when the page is closed.
*   **Push Notifications:** Receiving push messages from a server.

SvelteKit provides built-in support and conventions for integrating Service Workers.

## Implementation Steps

1.  **Create `src/service-worker.js` (or `.ts`):**
    *   This file contains your service worker logic.
    *   It runs in a separate thread and has access to Service Worker APIs (`self`, `caches`, `fetch`, `addEventListener`).
    *   **Important:** It does *not* have access to the DOM or regular SvelteKit modules directly.
2.  **Import Build Files & Version:**
    *   SvelteKit provides virtual modules (via Vite) to access information about your build:
        *   `import { build, files, prerendered, version } from '$service-worker';`
        *   `build`: Array of URLs for files generated by Vite (JS, CSS chunks).
        *   `files`: Array of URLs for static assets in your `static` directory.
        *   `prerendered`: Array of URLs for pre-rendered pages.
        *   `version`: A unique string identifying the current build (changes when build output changes). Useful for cache busting.
3.  **Define Cache Name:** Create a unique cache name, often incorporating the `version`.
4.  **`install` Event:**
    *   Fires when the service worker is first installed or updated.
    *   Use `event.waitUntil()` to ensure installation completes before the service worker becomes active.
    *   Typically used to **cache essential application assets** (`build`, `files`, prerendered routes) using the Cache API (`caches.open()`, `cache.addAll()`).
5.  **`activate` Event:**
    *   Fires after installation when the service worker takes control.
    *   Use `event.waitUntil()` to ensure activation completes.
    *   Typically used to **clean up old caches** associated with previous versions.
6.  **`fetch` Event:**
    *   Fires for **every network request** made by pages controlled by the service worker.
    *   Crucial for implementing offline strategies.
    *   Use `event.respondWith()` to intercept the request and provide a custom response.
    *   **Common Strategies:**
        *   **Cache First:** Check the cache first. If found, return cached response. If not, fetch from network, cache the response, and return it. Good for static assets.
        *   **Network First:** Try fetching from the network first. If successful, cache and return response. If network fails (offline), return response from cache. Good for frequently updated data where freshness is preferred.
        *   **Stale-While-Revalidate:** Return response from cache immediately (if available), then fetch from network in the background to update the cache for the next request. Good balance for non-critical, frequently updated content.
        *   **Cache Only / Network Only:** Simpler strategies.

## Example `src/service-worker.ts` (Cache First for Assets)

```typescript
/// <reference types="@sveltejs/kit" />
import { build, files, prerendered, version } from '$service-worker';
import type { PrecacheEntry } from '@workbox-precaching'; // Example using Workbox types

// Create a unique cache name for this deployment
const CACHE_NAME = `cache-${version}`;

// List of assets to cache on install
const ASSETS_TO_CACHE = build.concat(files).concat(prerendered);
// You might want to filter ASSETS_TO_CACHE further, e.g., exclude source maps
// const filteredAssets = ASSETS_TO_CACHE.filter(url => !url.endsWith('.map'));

// --- Install Event ---
self.addEventListener('install', (event) => {
	console.log('[Service Worker] Install event');
	// Cast self to ServiceWorkerGlobalScope for TypeScript
	const sw = self as unknown as ServiceWorkerGlobalScope;

	event.waitUntil(
		caches
			.open(CACHE_NAME)
			.then((cache) => {
				console.log('[Service Worker] Caching app shell');
				// Add all essential assets to the cache
				return cache.addAll(ASSETS_TO_CACHE);
			})
			.then(() => {
				// Force the waiting service worker to become the active service worker.
				sw.skipWaiting();
			})
	);
});

// --- Activate Event ---
self.addEventListener('activate', (event) => {
	console.log('[Service Worker] Activate event');
	const sw = self as unknown as ServiceWorkerGlobalScope;

	// Remove previous cached data from disk
	event.waitUntil(
		caches.keys().then(async (cacheNames) => {
			await Promise.all(
				cacheNames.map(async (cacheName) => {
					if (cacheName !== CACHE_NAME) {
						console.log('[Service Worker] Deleting old cache:', cacheName);
						await caches.delete(cacheName);
					}
				})
			);
		}).then(() => {
            // Tell the active service worker to take control of the page immediately.
            sw.clients.claim();
        })
	);
});

// --- Fetch Event ---
self.addEventListener('fetch', (event) => {
	const req = event.request;
	console.log(`[Service Worker] Fetching ${req.url}`);

	// Ignore non-GET requests
	if (req.method !== 'GET') {
		return;
	}

    // Ignore requests for external resources (optional, depends on strategy)
    // if (!req.url.startsWith(self.location.origin)) {
    //     return;
    // }

	// Cache First Strategy for assets
	event.respondWith(
		caches.match(req).then((cachedResponse) => {
			// Return cached response if found
			if (cachedResponse) {
				console.log(`[Service Worker] Returning cached response for ${req.url}`);
				return cachedResponse;
			}

			// If not in cache, fetch from network
			console.log(`[Service Worker] Fetching from network: ${req.url}`);
			return fetch(req).then(async (networkResponse) => {
                // Optional: Cache the network response for future requests
                // Be careful caching opaque responses (cross-origin without CORS)
                if (networkResponse.ok /* && networkResponse.type !== 'opaque' */) {
                    try {
                        const cache = await caches.open(CACHE_NAME);
                        // Clone response as it can only be consumed once
                        await cache.put(req, networkResponse.clone());
                        console.log(`[Service Worker] Cached network response for ${req.url}`);
                    } catch (cacheError) {
                        console.error(`[Service Worker] Failed to cache ${req.url}:`, cacheError);
                    }
                }
                return networkResponse;
            }).catch(error => {
                // Handle network fetch errors (e.g., offline)
                console.error(`[Service Worker] Network fetch failed for ${req.url}:`, error);
                // Optional: Return a fallback offline page/response
                // return caches.match('/offline.html');
                throw error; // Re-throw if not handling offline explicitly
            });
		})
	);
});

```

## Enabling the Service Worker

SvelteKit automatically registers the service worker if `src/service-worker.js` or `src/service-worker.ts` exists. No manual registration in your application code is typically needed.

Service workers are powerful but complex. Test thoroughly, especially caching strategies and update flows. Libraries like Workbox can simplify common patterns like precaching and runtime caching strategies.

*(Refer to the official SvelteKit documentation on Service Workers.)*