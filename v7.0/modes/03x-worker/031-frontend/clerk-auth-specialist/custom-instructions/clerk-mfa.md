# Clerk: Multi-Factor Authentication (MFA)

Enabling and managing Multi-Factor Authentication (MFA) with Clerk.

## Core Concept

Multi-Factor Authentication (MFA), also known as Two-Factor Authentication (2FA), adds an extra layer of security to user accounts by requiring users to provide two or more verification factors to sign in. Clerk provides built-in support for various MFA methods.

**Supported Factors (Common):**

*   **Authenticator App (TOTP):** Time-based One-Time Passwords generated by apps like Google Authenticator, Authy, etc.
*   **SMS Codes:** One-time codes sent via text message.
*   **Backup Codes:** Recovery codes provided to the user upon setup.

## Enabling MFA

MFA is configured primarily within your Clerk Dashboard:

1.  **Navigate to Settings:** Go to your Clerk application's dashboard.
2.  **Find MFA Settings:** Locate the "Multi-factor authentication" section (often under "Authentication" or "Security").
3.  **Enable Factors:** Choose which MFA factors you want to allow users to enable (e.g., Authenticator App, SMS).
4.  **Set Requirement Level (Optional):** You can configure whether MFA is optional, required for all users, or required only for users with specific roles (if using Organizations).

## Frontend Integration

Clerk's pre-built components handle the MFA enrollment and verification flows automatically when MFA is enabled in the dashboard.

*   **`<SignUp>`:** If MFA is required or enabled, the sign-up flow may include steps for the user to set up an MFA factor immediately after creating their account.
*   **`<SignIn>`:** If a user has MFA enabled, the sign-in flow will automatically prompt them for their second factor (e.g., TOTP code, SMS code) after they successfully enter their primary factor (e.g., password).
*   **`<UserProfile>`:** Provides the interface for users to manage their MFA settings:
    *   Add or remove Authenticator Apps.
    *   Add or verify phone numbers for SMS codes.
    *   View and manage backup codes.
    *   Set a preferred MFA method.

**Example (Rendering UserProfile for MFA Management):**

```jsx
// Example User Profile Page (Next.js App Router)
// src/app/user-profile/[[...user-profile]]/page.tsx
import { UserProfile } from "@clerk/nextjs";

export default function UserProfilePage() {
  return (
     <div style={{ display: 'flex', justifyContent: 'center', padding: '2rem' }}>
       {/* UserProfile component includes MFA management sections */}
       <UserProfile path="/user-profile" routing="path" />
     </div>
  );
}
```

## Custom UI with Clerk Elements

If building a custom UI with Clerk Elements, you need to handle the MFA steps explicitly:

*   **`<SignIn.Step name="verifications">` / `<SignUp.Step name="verifications">`:** These steps are used for MFA verification during sign-in or enrollment during sign-up.
*   **Elements within Verification Steps:** Use elements like `<SignIn.Action strategy="verification_code" submit>` and `<SignIn.Input name="code">` to handle code input (TOTP or SMS). Clerk Elements manage the logic for sending codes and verifying them based on the user's configured factors.

```jsx
// Simplified Example within CustomSignInForm using Elements
import * as SignIn from '@clerk/elements/sign-in';
import * as Clerk from '@clerk/elements/common';

// ... inside <SignIn.Root> ...

<SignIn.Step name="verifications" asChild>
  <form>
    <p>Enter the code from your authenticator app or SMS.</p>
    {/* Input for TOTP/SMS code */}
    <SignIn.Action strategy="verification_code" submit>
      <div>
        <label htmlFor="code">Verification Code</label>
        <SignIn.Input name="code" type="text" required inputMode="numeric" />
      </div>
      <button type="submit">Verify Code</button>
      <SignIn.GlobalError className="error-message" />
      <SignIn.FieldError name="code" className="error-message" />
    </SignIn.Action>

    {/* Option to use backup code */}
    <SignIn.Action navigate="choose-strategy" strategy="backup_code">
      <button type="button">Use Backup Code</button>
    </SignIn.Action>

    <SignIn.Action navigate="previous">
      <button type="button">Back</button>
    </SignIn.Action>
  </form>
</SignIn.Step>

{/* Step for Backup Code */}
<SignIn.Step name="backup_code" asChild>
   <form>
     <p>Enter one of your backup codes.</p>
     <SignIn.Action strategy="backup_code" submit>
       <div>
         <label htmlFor="backup-code">Backup Code</label>
         <SignIn.Input name="code" type="text" required />
       </div>
       <button type="submit">Verify Backup Code</button>
       <SignIn.GlobalError className="error-message" />
       <SignIn.FieldError name="code" className="error-message" />
     </SignIn.Action>
     <SignIn.Action navigate="previous">
       <button type="button">Back</button>
     </SignIn.Action>
   </form>
</SignIn.Step>

<Clerk.Loading>
  <div className="loading-overlay">Verifying...</div>
</Clerk.Loading>
```

## Backend Considerations

*   MFA status is typically handled automatically during session verification by Clerk's backend SDKs/middleware. The session token is usually only considered fully valid if the required MFA checks have passed.
*   You generally don't need specific backend code *just* for MFA verification itself if using Clerk's standard flows, but you might access user MFA status via the Backend API (`clerkClient.users.getUser(userId)`) for administrative purposes.

Clerk significantly simplifies the implementation of Multi-Factor Authentication by handling the complex enrollment and verification flows. Configuration is primarily done through the Clerk Dashboard, and the pre-built UI components adapt automatically.

*(Refer to the official Clerk MFA documentation.)*