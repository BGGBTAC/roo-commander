# MySQL: Schema Migration Strategies

Approaches for managing changes to MySQL database schemas over time.

## Core Concept

As applications evolve, their database schema requirements change (new tables, columns, modified types, indexes). Managing these changes systematically across different environments (development, testing, production) and coordinating with code deployments is crucial. This process is called schema migration.

## Common Strategies & Tools

1.  **Manual SQL Scripts:**
    *   **Concept:** Developers manually write SQL scripts (`.sql` files) containing DDL statements (`CREATE TABLE`, `ALTER TABLE`, `CREATE INDEX`, etc.) for each required schema change.
    *   **Execution:** Scripts are run manually against the database using a MySQL client (`mysql` command-line tool, GUI tools like MySQL Workbench, DBeaver) in a specific order.
    *   **Tracking:** Requires a manual system (e.g., naming convention like `001_create_users.sql`, `002_add_email_to_users.sql`, a separate log table, or notes) to track which scripts have been applied to which environment.
    *   **Pros:** Simple for small projects or infrequent changes. Full control over the exact SQL executed. No framework dependency.
    *   **Cons:** Error-prone (manual tracking, typos). Difficult to manage rollbacks consistently. Harder to coordinate in teams. Doesn't integrate directly with application code versioning.

2.  **Framework-Integrated Migration Tools:**
    *   **Concept:** Many web frameworks provide built-in tools or integrate with libraries that manage migrations based on code definitions (e.g., ORM models) or dedicated migration files.
    *   **Examples:**
        *   **Laravel:** Uses migration classes in `database/migrations/` generated by `php artisan make:migration`. Schema defined using PHP methods (`Schema::create`, `$table->string(...)`). Managed by `php artisan migrate`, `migrate:rollback`, etc. (See `migrations-seeding.md` in `php-laravel-developer` context).
        *   **Django:** Uses migration files in `app/migrations/` generated by `python manage.py makemigrations`. Based on changes detected in `models.py`. Managed by `python manage.py migrate`.
        *   **Flask-Migrate (Alembic):** Uses Alembic library. Generates Python migration scripts in `migrations/versions/` based on Flask-SQLAlchemy model changes. Managed by `flask db migrate`, `flask db upgrade`, `flask db downgrade`. (See `flask-migrate-alembic.md` in `flask-developer` context).
        *   **Sequelize CLI (Node.js):** Uses migration files (JS) defining `up` and `down` functions. Managed by `sequelize-cli db:migrate`, `db:migrate:undo`.
        *   **TypeORM CLI (Node.js/TypeScript):** Can auto-generate migrations from entity changes or use manually written migration files. Managed by `typeorm migration:run`, `migration:revert`.
    *   **Pros:** Integrates with application code/models. Often automates generation of `up`/`down` scripts. Provides commands for applying, rolling back, and checking status. Better team coordination. Version controlled alongside application code.
    *   **Cons:** Tied to a specific framework or library. Auto-generation might need manual review/editing for complex changes.

3.  **Standalone Database Migration Tools:**
    *   **Concept:** Dedicated tools focused solely on database schema migrations, often framework-agnostic. Typically use SQL files or a specific DSL for defining changes.
    *   **Examples:**
        *   **Alembic:** (Used by Flask-Migrate) Can be used standalone for any SQLAlchemy project.
        *   **Flyway:** Popular Java-based tool. Uses versioned SQL scripts (`V1__description.sql`, `V2__...`) or Java-based migrations. Tracks applied migrations in a metadata table.
        *   **Liquibase:** XML, YAML, JSON, or SQL formatted changelogs. Supports various databases. Tracks applied changesets.
        *   **DBMate:** Simple, framework-agnostic tool using plain SQL files with timestamp prefixes. Tracks applied migrations in a schema_migrations table.
    *   **Pros:** Database/framework agnostic (mostly). Often support advanced features like repeatable migrations, rollbacks, dry runs. Clear separation from application code.
    *   **Cons:** Requires learning the specific tool's conventions and commands. Might require separate configuration and execution steps from application deployment.

## Best Practices

*   **Version Control:** Always commit migration files (whether SQL scripts or framework-generated files) to your version control system (Git) along with the corresponding application code changes.
*   **Incremental Changes:** Make small, incremental changes in each migration script/file. Avoid huge, complex migrations.
*   **Reversibility (`down` Method):** Always write the corresponding `down` logic to reverse a migration whenever possible. This is crucial for rollbacks during development or failed deployments. Test the `down` migration.
*   **Idempotency:** Design migrations to be safe to run multiple times if possible (e.g., use `CREATE TABLE IF NOT EXISTS`, `ADD COLUMN IF NOT EXISTS`). However, rely primarily on the migration tool's tracking mechanism to prevent re-running applied migrations.
*   **No Data Manipulation (Generally):** Migrations should primarily focus on *schema* changes. Handle complex *data* transformations separately (e.g., in dedicated data migration scripts or seeders run after schema migration), as data changes are often harder to roll back reliably. Simple data updates (like setting a default for a new non-null column) might be acceptable within a schema migration.
*   **Test Migrations:** Always test migrations thoroughly in a development or staging environment that mirrors production as closely as possible before applying them to production. Test both `up` and `down` paths.
*   **Review Migrations:** Review migration scripts (especially auto-generated ones) before applying them to catch potential issues or unintended consequences.
*   **Production Deployment:**
    *   **Backup First:** **ALWAYS** back up the production database before running migrations.
    *   **Maintenance Mode:** Consider putting the application in maintenance mode during migration application to prevent data inconsistencies.
    *   **Coordinate:** Coordinate database migrations with application code deployments. Ensure the correct code version is deployed before/after the corresponding migration runs.
*   **Team Coordination:** Establish clear processes for creating, reviewing, and applying migrations in a team environment to avoid conflicts (e.g., developers run `migrate` locally before creating new migrations, use feature branches).

Choosing the right migration strategy depends on your project's stack, team size, and complexity. Framework-integrated tools are often the most convenient for typical web applications.

*(Refer to documentation for specific frameworks or standalone migration tools.)*