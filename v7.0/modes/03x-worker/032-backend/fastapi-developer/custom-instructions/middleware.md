# FastAPI: Middleware

Using middleware to run code before and after requests are processed in FastAPI.

## Core Concept

Middleware in FastAPI (and underlying Starlette) are functions or classes that process requests before they reach the path operation function and process responses before they are sent back to the client. They allow you to implement cross-cutting concerns across multiple (or all) endpoints.

## Use Cases

*   Adding custom headers to responses.
*   Logging request/response details.
*   Handling CORS (Cross-Origin Resource Sharing).
*   Implementing GZip compression.
*   Adding global exception handling.
*   Modifying request objects before they reach the path operation.
*   Measuring request processing time.
*   Implementing certain types of authentication/authorization checks (though dependency injection is often preferred for auth logic tied to specific endpoints).

## Adding Middleware

Middleware is added to the FastAPI application instance using `app.add_middleware()`. The order matters, as middleware are processed sequentially.

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from fastapi.middleware.gzip import GZipMiddleware
import time
from starlette.requests import Request
from starlette.responses import Response

app = FastAPI()

# Example 1: Adding built-in CORS Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "https://myapp.com"], # List of allowed origins
    allow_credentials=True,
    allow_methods=["*"], # Allow all methods (GET, POST, etc.)
    allow_headers=["*"], # Allow all headers
)

# Example 2: Adding built-in TrustedHost Middleware (Security)
# Prevents Host header attacks
app.add_middleware(
    TrustedHostMiddleware, allowed_hosts=["example.com", "*.example.com", "localhost"]
)

# Example 3: Adding built-in GZip Middleware (Performance)
# Compresses responses for clients that support it
app.add_middleware(GZipMiddleware, minimum_size=1000) # Only gzip responses >= 1000 bytes

# Example 4: Custom Middleware using @app.middleware("http") decorator
@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.time()
    # Process the request (call the next middleware or path operation)
    response: Response = await call_next(request)
    # Code here runs *after* the response is generated
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    print(f"Request {request.method} {request.url.path} processed in {process_time:.4f} secs")
    return response

# Example 5: Custom Middleware using BaseHTTPMiddleware (alternative class-based approach)
# from starlette.middleware.base import BaseHTTPMiddleware, RequestResponseCall
# class CustomHeaderMiddleware(BaseHTTPMiddleware):
#     async def dispatch(self, request: Request, call_next: RequestResponseCall):
#         response = await call_next(request)
#         response.headers['X-Custom-Header'] = 'MyValue'
#         return response
# app.add_middleware(CustomHeaderMiddleware)


@app.get("/")
async def root():
    return {"message": "Hello World"}

```

## Middleware Types

*   **ASGI Middleware:** The most common type, operating directly on the ASGI `scope`, `receive`, and `send` messages. `CORSMiddleware`, `TrustedHostMiddleware`, `GZipMiddleware` are examples. Added via `app.add_middleware()`.
*   **`@app.middleware("http")` Decorator:** A simpler way to define custom ASGI middleware directly within your FastAPI application file. The decorated function receives the `request` and a `call_next` function (which you `await` to pass control down the chain). Code *after* `await call_next(request)` runs after the response has been generated by the path operation or subsequent middleware.
*   **`BaseHTTPMiddleware`:** A Starlette class providing a slightly higher-level abstraction for creating custom middleware, especially useful if you need class-based organization or state within the middleware instance. Added via `app.add_middleware()`.

## Order of Execution

Middleware are processed in the order they are added:

1.  Request comes in.
2.  First middleware added processes the request (code before `await call_next`).
3.  Second middleware added processes the request (code before `await call_next`).
4.  ...
5.  Path operation function is executed.
6.  ...
7.  Second middleware added processes the response (code after `await call_next`).
8.  First middleware added processes the response (code after `await call_next`).
9.  Response is sent to the client.

## Middleware vs. Dependencies

*   **Middleware:** Applied more broadly (often globally). Good for cross-cutting concerns like logging, CORS, compression, adding global headers, basic request validation/modification. Operates on the raw request/response.
*   **Dependencies (`Depends`):** Applied per-path operation (or router). Better for logic specific to certain endpoints, sharing business logic, managing resources like database sessions, complex parameter processing, and fine-grained authentication/authorization tied to specific operations. Operates with parsed/validated data (Pydantic models, parameters).

Often, a combination is used (e.g., middleware for CORS and logging, dependencies for authentication and database sessions).

*(Refer to the official FastAPI Middleware documentation: https://fastapi.tiangolo.com/tutorial/middleware/ and Advanced Middleware: https://fastapi.tiangolo.com/advanced/middleware/)*