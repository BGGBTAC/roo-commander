# FastAPI: Pydantic Models for Data Validation & Serialization

Using Pydantic's `BaseModel` for defining data shapes, validation, and serialization in FastAPI.

## Core Concept: Data Shapes with Type Hints

Pydantic is a data validation and settings management library that uses Python type hints. FastAPI leverages Pydantic models (`BaseModel`) extensively to define the expected structure and types of data in API requests and responses.

**Benefits:**

*   **Automatic Validation:** FastAPI automatically validates incoming request bodies against the Pydantic model defined in the path operation function's parameters. If validation fails, it returns a clear HTTP 422 error response detailing the issues.
*   **Serialization:** Data returned from path operations (if a `response_model` is specified) is automatically serialized according to the Pydantic model, ensuring the response matches the defined schema.
*   **Automatic Documentation:** Pydantic models are used to generate JSON Schema definitions within the OpenAPI documentation, making the API structure clear and enabling interactive documentation (Swagger UI / ReDoc).
*   **Editor Support:** Provides excellent autocompletion and type checking within your editor for model attributes.
*   **Data Conversion:** Pydantic attempts to convert incoming data to the declared types where possible (e.g., string "true" to boolean `True`).

## Defining Models (`schemas.py` or `models.py`)

It's common practice to define Pydantic models in a separate file, often named `schemas.py`.

```python
# schemas.py
from pydantic import BaseModel, Field, EmailStr, HttpUrl
from typing import List, Optional # Use Optional for Python < 3.10, | None for >= 3.10
from datetime import datetime

# --- Request Body Models ---

class ItemCreate(BaseModel):
    name: str = Field(..., min_length=3, max_length=50, description="Name of the item")
    description: Optional[str] = Field(None, description="Optional description") # Optional field
    price: float = Field(..., gt=0, description="Price must be greater than zero")
    tags: List[str] = Field([], description="List of tags") # List field, defaults to empty

    # Example configuration for automatic documentation
    class Config:
        schema_extra = {
            "example": {
                "name": "Example Item",
                "description": "A useful item.",
                "price": 19.99,
                "tags": ["new", "featured"]
            }
        }

class UserCreate(BaseModel):
    username: str = Field(..., min_length=3)
    email: EmailStr # Pydantic type for email validation
    password: str = Field(..., min_length=8)

# --- Response Models ---
# Often useful to have separate models for responses to control exposed data

class ItemResponse(BaseModel):
    id: int # Assuming ID is generated by the database
    name: str
    description: Optional[str] = None
    price: float
    tags: List[str] = []

    # Pydantic V2: Use model_config instead of Config
    # model_config = {
    #     "from_attributes": True # Allow creating model from ORM object attributes
    # }
    class Config:
        orm_mode = True # Pydantic V1: Allow creating model from ORM object attributes

class UserResponse(BaseModel):
    id: int
    username: str
    email: EmailStr
    is_active: bool = True
    created_at: datetime

    class Config:
        orm_mode = True

```

**Key Pydantic Features:**

*   **`BaseModel`:** Inherit from this to create your data models.
*   **Type Hints:** Use standard Python types (`str`, `int`, `float`, `bool`, `list`, `dict`, `datetime`, etc.) and types from `typing` (`List`, `Optional`, `Union`, `Any`).
*   **`Field()`:** Used to provide extra validation rules and metadata:
    *   `...` (Ellipsis): Marks a field as required.
    *   `default=None` or `Optional[type]` or `type | None`: Marks a field as optional.
    *   `min_length`, `max_length`: For strings.
    *   `gt`, `ge`, `lt`, `le`: For numbers (greater than, greater/equal, less than, less/equal).
    *   `description`: Adds description to OpenAPI schema.
    *   `example`: Adds example data to OpenAPI schema.
    *   `alias`: Use a different name for the field in JSON.
*   **Special Types:** Pydantic provides useful types like `EmailStr`, `HttpUrl`, `UUID`, etc., for specific format validation.
*   **Nested Models:** You can nest Pydantic models within each other (e.g., an `Order` model containing a `List[Item]`).
*   **`Config` / `model_config`:** Inner class or attribute for configuring model behavior (e.g., `orm_mode`/`from_attributes` for ORM integration, `schema_extra` for examples).

## Using Models in FastAPI

```python
# main.py
from fastapi import FastAPI, HTTPException, Depends, status
from typing import List
import schemas # Import your models file

app = FastAPI()

# In-memory "database" for example
fake_items_db = []
fake_users_db = []

@app.post("/items/", response_model=schemas.ItemResponse, status_code=status.HTTP_201_CREATED)
async def create_item(item: schemas.ItemCreate): # Use ItemCreate for request body validation
    # 'item' is now a validated instance of ItemCreate
    new_item_data = item.dict()
    new_item_data["id"] = len(fake_items_db) + 1 # Simulate ID generation
    fake_items_db.append(new_item_data)
    # Return data matching ItemResponse (FastAPI handles serialization)
    return new_item_data

@app.get("/items/", response_model=List[schemas.ItemResponse]) # Response is a list of items
async def read_items(skip: int = 0, limit: int = 10):
    return fake_items_db[skip : skip + limit]

@app.get("/items/{item_id}", response_model=schemas.ItemResponse)
async def read_item(item_id: int):
    if item_id < 1 or item_id > len(fake_items_db):
        raise HTTPException(status_code=404, detail="Item not found")
    return fake_items_db[item_id - 1]

# Example using User models
@app.post("/users/", response_model=schemas.UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(user: schemas.UserCreate):
    # In a real app, hash the password here before saving
    user_data = user.dict()
    user_data["id"] = len(fake_users_db) + 1
    user_data["is_active"] = True
    user_data["created_at"] = datetime.utcnow()
    fake_users_db.append(user_data)
    # Exclude password from response automatically via UserResponse model
    return user_data

```

Pydantic models are fundamental to FastAPI. Define them clearly using type hints and `Field` for validation rules. Use separate models for creation/input (`ItemCreate`) and output (`ItemResponse`) to control data exposure and validation requirements. FastAPI automatically uses these models for validation, serialization, and documentation.